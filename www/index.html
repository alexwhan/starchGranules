  <script>
// var parseTime = d3.timeParse("%Y%m%d");

  var networkOutputBinding = new Shiny.OutputBinding();
  var lines = {"counter":0, "brushed": false}
  var hoverLineGroup, hoverLine, hoverText, brush;
  var lineHeight = 40;
  var svg, margin, width, height, g, x, y, z, line;
  var mydata;
  var xAxis, yAxis;


  $.extend(networkOutputBinding, {
    find: function(scope) {
		return $(scope).find('.shiny-network-output');
    },
    renderValue: function(el, data) {
    	if(!data) return;
    	// mydata = data;
    	d3.select("div#mastersizer")
	   .append("div")
	   .classed("svg-container", true) //container class to make it responsive
	   .append("svg")
	   //responsive SVG needs these 2 attributes and no width and height attr
	   .attr("preserveAspectRatio", "xMinYMin meet")
	   .attr("viewBox", "0 0 600 400")
	   //class to make it responsive
	   .classed("svg-content-responsive", true); 
    	drawGraph(data);
    	// d3(document).on("resize", function(){ drawGraph(data);})
	}
})



function drawGraph(data){
	// var data = mydata;
  	console.log(data);
  	// console.log("I am here");
  	// var container = d3.select("#mastersizer");
  	// console.log(container);
  	svg = d3.select("svg")
  	svg.selectAll("*").remove();
  	// svg.attr("width", container.node().getBoundingClientRect().width);
  	// svg.attr("height", 500);
	margin = {top: 20, right: 80, bottom: 30, left: 50};
	console.log(svg.node().getBoundingClientRect())
	width = svg.node().getBoundingClientRect().width - margin.left - margin.right;
	height = 400 - margin.top - margin.bottom;
	g = svg.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");

  	brush = d3.brush().on("end", brushended);
	
	svg.append("g")
    .attr("class", "brush")
    .call(brush);

	x = d3.scaleLog().range([0, width]);
	y = d3.scaleLinear().range([height, 0]);
	z = d3.scaleOrdinal(d3.schemeCategory10);
	line = d3.line()
		.curve(d3.curveBasis)
		.x(function(d) { return x(d.psize); })
		.y(function(d) { return y(d.frequency); });


  	// Hover line. 
	hoverLineGroup = svg.append("g")
		.attr("class", "hover-line");
	hoverLine = hoverLineGroup
		.append("line")
		.attr("x1", 0).attr("x2", 0) 
		.attr("y1", margin.top).attr("y2", height + margin.top); 

	hoverText = hoverLineGroup.append('text')
		.attr("class", "hover-text")
		.attr('y', margin.top + 20);

	
	// Hide hover line by default.
	hoverLineGroup.style("opacity", 1e-6);

	// console.log("I am here");
	var size = data.size;
	var samples = []
	for(xx in data){
		if(xx=="size") continue;
		var myobj = {id: xx, values: []}
		for(var i=0; i<size.length; i++){
			myobj.values.push({psize: parseFloat(size[i]), frequency: data[xx][i]})
		}
		samples.push(myobj);
	}

	// console.log(samples);
	x.domain(d3.extent(data.size, function(d) { return d; }));

	y.domain([
	  d3.min(samples, function(c) { return d3.min(c.values, function(d) { return d.frequency; }); }),
	  d3.max(samples, function(c) { return d3.max(c.values, function(d) { return d.frequency; }); })
	  ]);

	z.domain(samples.map(function(c) { return c.id; }));
	xAxis =  d3.axisBottom(x);
	yAxis = d3.axisLeft(y);

	g.append("g")
		.attr("class", "axis axis--x")
		.attr("transform", "translate(0," + height + ")")
		.call(xAxis);

	g.append("g")
		.attr("class", "axis axis--y")
		.call(yAxis)
		.append("text")
		.attr("transform", "rotate(-90)")
		.attr("y", 6)
		.attr("dy", "0.71em")
		.attr("fill", "#000")
		.text("Frequency");

	var sample = g.selectAll(".sample")
		.data(samples)
		.enter().append("g")
		.attr("class", "sample");

	sample.append("path")
		.attr("class", "line")
		.attr("d", function(d) { return line(d.values); })
		.style("stroke", function(d) { return z(d.id); });

	sample.append("text")
		.datum(function(d) { return {id: d.id, value: d.values[d.values.length - 1]}; })
		.attr("transform", function(d) { console.log(d.value); return "translate(" + x(d.value.psize) + "," + y(d.value.frequency) + ")"; })
		.attr("x", 3)
		.attr("dy", "0.35em")
		.style("font", "10px sans-serif")
		.text(function(d) { return d.id; });

	// Add mouseover events.
	d3.select("svg").on("mousemove", function() {
		if(lines.counter >= 3 || !lines.brushed) return;
		//console.log('mousemove', d3.mouse(this));
		var mouse_x = d3.mouse(this)[0];
		var mouse_y = d3.mouse(this)[1];

		// var graph_y = y.invert(mouse_y);
		var graph_x = x.invert(mouse_x);
		// console.log(mouse_x + " " + mouse_y + " " + graph_y + " " + graph_x);
		var char = "A", counter = 0;
		if(!lines.A){char="A"; }
		else if(!lines.B){char="B"; counter=1;}
		else if(!lines.C){char="C"; counter=2;}

		hoverLine.attr("x1", mouse_x).attr("x2", mouse_x);
		hoverText.text("("+char+") "+graph_x)
			.attr('y', margin.top + 20 + lineHeight*counter);
		// hoverText.text(graph_x);
	  	hoverText.attr('x', mouse_x + 10);
		hoverLineGroup.style("opacity", 1);

	}).on("mouseout", function() {
	    // console.log('mouseout');
	    hoverLineGroup.style("opacity", 1e-6);
	}).on('click', function(){
		if(lines.counter >= 3 || !lines.brushed) return;
		var mouse_x = d3.mouse(this)[0];
		// var mouse_y = d3.mouse(this)[1];

		// var graph_y = y.invert(mouse_y);
		var graph_x = x.invert(mouse_x);

		var lineGroup = svg.append("g").attr("class", "hover-line");

		var char = "A", counter = 0;
		if(!lines.A){lines.A = lineGroup; char="A"; }
		else if(!lines.B){lines.B = lineGroup; char="B"; counter=1;}
		else if(!lines.C){lines.C = lineGroup; char="C"; counter=2;}

		var line = lineGroup
			.append("line")
			.attr("x1", mouse_x).attr("x2", mouse_x) 
			.attr("y1", margin.top).attr("y2", height + margin.top); 

		// console.log(mouse_x + " " + graph_x);
		var text = lineGroup.append('text')
		   .attr("class", "hover-text")
		   .attr('y', margin.top + 20 + lineHeight*counter)
		   .attr('x', mouse_x + 10)
		   .text("("+char+") "+graph_x);
		Shiny.onInputChange("peak_"+char, graph_x);

		text.on("dblclick", function(){
				lineGroup.remove();
				lines.counter--;
				delete lines[char];
			})
		lines.counter++;
	});	
}
Shiny.outputBindings.register(networkOutputBinding, 'alexwhan.networkbinding');

function brushended() {
	var s = d3.event.selection;
	console.log(s);
	if (!s) {
		console.log("not s");
		return;
		// if (!idleTimeout) return idleTimeout = setTimeout(idled, idleDelay);
		// x.domain(x0);
		// y.domain(y0);
	} else {
		console.log("yes s");
		x.domain([s[0][0], s[1][0]].map(x.invert, x));
		Shiny.onInputChange("min_val", x.invert(s[0][0]));
		Shiny.onInputChange("max_val", x.invert(s[1][0]));
		y.domain([s[1][1], s[0][1]].map(y.invert, y));
		svg.select(".brush").call(brush.move, null);
	}
	lines.brushed = true;
	zoom();
}

function idled() {
	idleTimeout = null;
}

function zoom() {
	var t = svg.transition().duration(750);
	svg.select(".axis--x").transition(t).call(xAxis);
	svg.select(".axis--y").transition(t).call(yAxis);
	console.log(svg.selectAll(".line"));
	svg.selectAll(".line").transition(t)
		.attr("d", function(d) { console.log({d:d}); return line(d.values); });
}

</script>
