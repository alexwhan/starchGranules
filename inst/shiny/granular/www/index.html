  <script>
// var parseTime = d3.timeParse("%Y%m%d");

  var networkOutputBinding = new Shiny.OutputBinding();
  var lines = {"counter":0, "brushed": false}
  var hoverLineGroup, hoverLine, hoverText, brush;
  var lineHeight = 40;
  var svg, margin, width, height, g, x, y, z, line;
  var mydata;
  var xAxis, yAxis;

  var x0,sample;
  var samples = [];

  $.extend(networkOutputBinding, {
    find: function(scope) {
		return $(scope).find('.shiny-network-output');
    },
    renderValue: function(el, data) {
    	if(!data) return;
    	d3.selectAll(".svg-container").remove();
    	// mydata = data;
    	d3.select("div#mastersizer")
	   .append("div")
	   .classed("svg-container", true) //container class to make it responsive
	   .append("svg")
	   //responsive SVG needs these 2 attributes and no width and height attr
	   .attr("preserveAspectRatio", "xMinYMin meet")
	   .attr("viewBox", "0 0 600 400")
	   //class to make it responsive
	   .classed("svg-content-responsive", true); 
    	drawGraph(data);
    	// d3(document).on("resize", function(){ drawGraph(data);})
	}
})



function drawGraph(data){
	// var data = mydata;
  	console.log(data);
  	// console.log("I am here");
  	// var container = d3.select("#mastersizer");
  	// console.log(container);
  	svg = d3.select("svg")
  	svg.selectAll("*").remove();
  	// svg.attr("width", container.node().getBoundingClientRect().width);
  	// svg.attr("height", 500);
	margin = {top: 20, right: 80, bottom: 30, left: 50};
	console.log(svg.node().getBoundingClientRect());

	width = 500;//svg.node().getBoundingClientRect().width - margin.left - margin.right;
	height = 400;
	g = svg.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");

	g = svg.append("g");
  	brush = d3.brushX().extent([[0, 0], [width, height]]).on("end", brushended);
  	//brush = d3.brush().on("end", brushended);
	
	svg.append("g")
    .attr("class", "brush")
    .call(brush);

	x = d3.scaleLog().range([0, width]);
	x0 = d3.scaleLog().range([0, width]);
	y = d3.scaleLinear().range([height, 0]);
	z = d3.scaleOrdinal(d3.schemeCategory10);


  	// Hover line. 
	hoverLineGroup = svg.append("g")
		.attr("class", "hover-line");

	hoverLine = hoverLineGroup
		.append("line")
		.attr("x1", 0).attr("x2", 0) 
		.attr("y1", 0).attr("y2", height); 

	hoverText = hoverLineGroup.append('text')
		.attr("class", "hover-text")
		.attr('y', 20);

	
	// Hide hover line by default.
	hoverLineGroup.style("opacity", 1e-6);

	var size = data.size;
	
	for(xx in data){
		if(xx=="size") continue;
		var myobj = {id: xx, values: []}
		for(var i=0; i<size.length; i++){
			myobj.values.push({psize: parseFloat(size[i]), frequency: data[xx][i]})
		}
		samples.push(myobj);
	}

	x.domain(d3.extent(data.size, function(d) { return d; }));
	x0.domain(d3.extent(data.size, function(d) { return d; }));

	y.domain( [
	  d3.min(samples, function(c) { return d3.min(c.values, function(d) { return d.frequency; }); }),
	  d3.max(samples, function(c) { return d3.max(c.values, function(d) { return d.frequency; }); })
	  ]);
	z.domain(samples.map(function(c) { return c.id; }));

	line = d3.line()
		.curve(d3.curveBasis)
		.x(function(d) { return x(d.psize); })
		.y(function(d) { return y(d.frequency); });

	xAxis =  d3.axisBottom(x);
	yAxis = d3.axisRight(y);

	g.append("g")
		.attr("class", "axis axis--x")
		.attr("transform", "translate(0," + height + ")")
		.call(xAxis);

	g.append("g")
		.attr("class", "axis axis--y")
		.call(yAxis)
		.append("text")
		//.attr("transform", "rotate(-90)")
		.attr("y", 15)
		.attr("x",10)
		.attr("dy", "0.71em")
		.attr("fill", "#000")
		.text("Frequency");

	sample = g.selectAll(".sample")
		.data(samples)
		.enter().append("g")
		.attr("class", "sample");

	sample.append("path")
		.attr("class", "line")
		.attr("d", function(d) { return line(d.values); })
		.style("stroke", function(d) { return z(d.id); });

	// Add mouseover events.
	d3.select("svg").on("mousemove", function() {
		var mouse_x = d3.mouse(this)[0];
		var graph_x = Math.round(x.invert(mouse_x)*100)/100;
	
		if(lines.counter >= 3 || !lines.brushed) return;
		var mouse_x = d3.mouse(this)[0];
		var graph_x = Math.round(x.invert(mouse_x)*100)/100;

		var char = "A", counter = 0;
		if(!lines.A){char="A"; }
		else if(!lines.B){char="B"; counter=1;}
		else if(!lines.C){char="C"; counter=2;}

		hoverLine.attr("x1", mouse_x).attr("x2", mouse_x);
		hoverText.text("("+char+") "+graph_x)
			.attr('y', 20 + lineHeight*counter);
	  	hoverText.attr('x', mouse_x + 10);
		hoverLineGroup.style("opacity", 1);

	}).on("mouseout", function() {
	    hoverLineGroup.style("opacity", 1e-6);
	}).on('click', function(){
		if(lines.counter >= 3 || !lines.brushed) return;
		var mouse_x = d3.mouse(this)[0];
		var graph_x = Math.round(x.invert(mouse_x)*100)/100;

		var lineGroup = svg.append("g").attr("class", "hover-line");

		var char = "A", counter = 0;
		if(!lines.A){lines.A = lineGroup; char="A"; }
		else if(!lines.B){lines.B = lineGroup; char="B"; counter=1;}
		else if(!lines.C){lines.C = lineGroup; char="C"; counter=2;}

		var line = lineGroup
			.append("line")
			.attr("x1", mouse_x).attr("x2", mouse_x) 
			.attr("y1", 0).attr("y2", height); 

		var text = lineGroup.append('text')
		   .attr("class", "hover-text")
		   .attr('y', 20 + lineHeight*counter)
		   .attr('x', mouse_x + 10)
		   .text("("+char+") "+graph_x);
				
		Shiny.onInputChange("peak_"+char, graph_x);

		text.on("dblclick", function(){
				lineGroup.remove();
				lines.counter--;
				delete lines[char];
			})
		lines.counter++;
	});	
}
Shiny.outputBindings.register(networkOutputBinding, 'alexwhan.networkbinding');

var min,max;
function brushended() {
	var s = d3.event.selection;
	console.log(s);

	//Only brush once
	if(lines.brushed) return;

	if (!s) {
		console.log("not s");
		return;
	} else {
		console.log("yes s:" + s);
		min = s[0];
		max = s[1];
		x.domain([s[0],s[1]].map(x.invert,x));
		Shiny.onInputChange("min_val", x0.invert(s[0]));
		Shiny.onInputChange("max_val", x0.invert(s[1]));
		svg.select(".brush").call(brush.move, null);
	}
	lines.brushed = true;
	zoom();
}

function idled() {
	idleTimeout = null;
}

function zoom() {
	var t = svg.transition().duration(750);
	svg.select(".axis--x").transition(t).call(xAxis);
	svg.selectAll(".line").transition(t)
	  	.attr("d", function(d) { return line(d.values); });
}

</script>
